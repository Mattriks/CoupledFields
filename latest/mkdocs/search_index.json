{
    "docs": [
        {
            "location": "/", 
            "text": "CoupledFields Documentation\n\n\n\n\nGuide Outline\n\n\n\n\nExample 1\n\n\nExample 2\n\n\nTropical Pacific SSTs\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nLibrary\n\n\nContents\n\n\nTypes\n\n\nFunctions", 
            "title": "Home"
        }, 
        {
            "location": "/#coupledfields-documentation", 
            "text": "", 
            "title": "CoupledFields Documentation"
        }, 
        {
            "location": "/#guide-outline", 
            "text": "Example 1  Example 2  Tropical Pacific SSTs", 
            "title": "Guide Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "Library  Contents  Types  Functions", 
            "title": "Library Outline"
        }, 
        {
            "location": "/man/Example1/", 
            "text": "Example 1\n\n\nusing StatsBase: zscore\nusing DataFrames, Gadfly\nusing CoupledFields\n\nfunction rHypersphere(n::Int, k::Int)\n    Q = qrfact(randn(k,k))[:Q]\n    return Q[:,1:n]  \nend\n\nfunction simfn(n::Int, p::Int,sc::Float64, sige::Float64)\n    Wx = rHypersphere(2,p)\n    Wy = rHypersphere(2,2)\n    X = sc*rand(n,p)-(sc/2)\n    E = sige*randn(n,1)\n    xstar = X * Wx\n    ystar = zscore([6.3*xstar[:,1].*exp(-0.1*xstar[:,1].^2) randn(n,1)],1)\n    Y =  ystar / Wy\n    return zscore(X,1), Y, xstar, ystar\nend\n\nfunction createDF{T\n:Matrix{Float64}}(c::Float64, X::T, Y::T, kpars::KernelParameters; sc=1.0)\n    \u2207g = hcat(gradvecfield([c -7.0], X, Y, kpars)...)'\n    vecf = [X-\u2207g*sc X+\u2207g*sc] \n    DataFrame(x=X[:,1], y=X[:,2], x1=vecf[:,1], y1=vecf[:,2], x2=vecf[:,3],y2=vecf[:,4], col=Y[:,1],\n        par=\n\u03c3=$c\n*\n\u03c3\nsub\nmed\n/sub\n)\nend\n\nsrand(1234)\nX, Y, xstar, ystar = simfn(200, 2,30.0, 0.1)\n\nkpars = GaussianKP(X)\nD1 = vcat([createDF(c, X, ystar[:,1:1], kpars, sc=0.05) for c in [0.5 0.05]  ]...)   ;\n\n\ncolscale = Scale.color_continuous(minvalue=-2.0, maxvalue=2.0)\ncoord = Coord.cartesian(xmin=-2.0, xmax=2.0, ymin=-2.0, ymax=2.0)\n\np = plot(D1,  xgroup=:par,\n    Geom.subplot_grid(coord,\n        layer(x=:x1, y=:y1,xend=:x2, yend=:y2, color=:col, Geom.vector),\n        layer(x=:x, y=:y, color=:col, Geom.point, Theme(default_point_size=2pt)) \n    ),\n    colscale,\n    Scale.x_continuous(minvalue=-2.0, maxvalue=2.0),\n    Scale.y_continuous(minvalue=-2.0, maxvalue=2.0),\n    Guide.xlabel(\nX\nsub\n1\n/sub\n),\n    Guide.ylabel(\nX\nsub\n2\n/sub\n),\n    Guide.colorkey(\nY\n)\n)", 
            "title": "Example 1"
        }, 
        {
            "location": "/man/Example1/#example-1", 
            "text": "using StatsBase: zscore\nusing DataFrames, Gadfly\nusing CoupledFields\n\nfunction rHypersphere(n::Int, k::Int)\n    Q = qrfact(randn(k,k))[:Q]\n    return Q[:,1:n]  \nend\n\nfunction simfn(n::Int, p::Int,sc::Float64, sige::Float64)\n    Wx = rHypersphere(2,p)\n    Wy = rHypersphere(2,2)\n    X = sc*rand(n,p)-(sc/2)\n    E = sige*randn(n,1)\n    xstar = X * Wx\n    ystar = zscore([6.3*xstar[:,1].*exp(-0.1*xstar[:,1].^2) randn(n,1)],1)\n    Y =  ystar / Wy\n    return zscore(X,1), Y, xstar, ystar\nend\n\nfunction createDF{T :Matrix{Float64}}(c::Float64, X::T, Y::T, kpars::KernelParameters; sc=1.0)\n    \u2207g = hcat(gradvecfield([c -7.0], X, Y, kpars)...)'\n    vecf = [X-\u2207g*sc X+\u2207g*sc] \n    DataFrame(x=X[:,1], y=X[:,2], x1=vecf[:,1], y1=vecf[:,2], x2=vecf[:,3],y2=vecf[:,4], col=Y[:,1],\n        par= \u03c3=$c * \u03c3 sub med /sub )\nend\n\nsrand(1234)\nX, Y, xstar, ystar = simfn(200, 2,30.0, 0.1)\n\nkpars = GaussianKP(X)\nD1 = vcat([createDF(c, X, ystar[:,1:1], kpars, sc=0.05) for c in [0.5 0.05]  ]...)   ;\n\n\ncolscale = Scale.color_continuous(minvalue=-2.0, maxvalue=2.0)\ncoord = Coord.cartesian(xmin=-2.0, xmax=2.0, ymin=-2.0, ymax=2.0)\n\np = plot(D1,  xgroup=:par,\n    Geom.subplot_grid(coord,\n        layer(x=:x1, y=:y1,xend=:x2, yend=:y2, color=:col, Geom.vector),\n        layer(x=:x, y=:y, color=:col, Geom.point, Theme(default_point_size=2pt)) \n    ),\n    colscale,\n    Scale.x_continuous(minvalue=-2.0, maxvalue=2.0),\n    Scale.y_continuous(minvalue=-2.0, maxvalue=2.0),\n    Guide.xlabel( X sub 1 /sub ),\n    Guide.ylabel( X sub 2 /sub ),\n    Guide.colorkey( Y )\n)", 
            "title": "Example 1"
        }, 
        {
            "location": "/man/Example2/", 
            "text": "Example 2\n\n\nusing StatsBase: zscore\nusing DataFrames, Compose, Gadfly\nusing CoupledFields\n\nfunction rHypersphere(n::Int, k::Int)\n    Q = qrfact(randn(k,k))[:Q]\n    return Q[:,1:n]  \nend\n\nfunction simfn(n::Int, p::Int, sc::Float64, sige::Float64)\n    Wx = rHypersphere(2,p)\n    Wy = rHypersphere(2,2)\n    X = sc*rand(n,p)-(sc/2)\n    E = sige*randn(n,1)\n    xstar = X * Wx\n    ystar = zscore([6.3*xstar[:,1].*exp(-0.1*xstar[:,1].^2) randn(n,1)],1)\n    Y =  ystar / Wy\n    return zscore(X,1), Y, xstar, ystar\nend\n\ncreateDF = function(df::Int, Y::Matrix{Float64})\n    Xs = bf(gKCCAm.R[:,1], df)\n    CCAm = cca([-9. -9.], Xs, Y)\n    return DataFrame(x=gkCCAm.R[:,1], y= CCAm.T[:,1], y2 = CCAm.R[:,1]-mean(CCAm.R[:,1]), df=\ni\ndf\n/i\n=$df\n)\nend    \n\nsrand(1234)\nX, Y, xstar, ystar = simfn(200, 2,30.0, 0.1)\n\nkpars = GaussianKP(X)\ngKCCAm = gKCCA([0.2, -5, 1], X, Y, kpars )\n\nplotfn = function(v) \n    mlfs = 10pt\n    D1= vcat([createDF(df, Y) for df in v]...)\n\nplot(D1, xgroup=:df,\n    Geom.subplot_grid(Coord.cartesian(ymin=-3, ymax=3),\n        layer(x=:x, y=:y2, Geom.line,  Theme(default_color=colorant\nred\n)),\n        layer(x=:x, y=:y, Geom.point)\n    ),\n    Guide.ylabel(\nb\nYA\n/b\nsub\n1\n/sub\n),\n    Theme(plot_padding=0mm, major_label_font_size=mlfs)\n )\nend\n\npb = plotfn(4:6)\nGadfly.add_plot_element!(pb, Guide.xlabel(\nb\nXW\n/b\nsub\n1\n/sub\n (gKCCA)\n ))\n\nM = Array(Compose.Context, (2,1))\nM[1] = compose(context(0,0, 1.0, 0.45), render(plotfn(1:3)))\nM[2] = compose(context(0,0, 1.0, 0.55), render(pb))\n\nvstack(M...)", 
            "title": "Example 2"
        }, 
        {
            "location": "/man/Example2/#example-2", 
            "text": "using StatsBase: zscore\nusing DataFrames, Compose, Gadfly\nusing CoupledFields\n\nfunction rHypersphere(n::Int, k::Int)\n    Q = qrfact(randn(k,k))[:Q]\n    return Q[:,1:n]  \nend\n\nfunction simfn(n::Int, p::Int, sc::Float64, sige::Float64)\n    Wx = rHypersphere(2,p)\n    Wy = rHypersphere(2,2)\n    X = sc*rand(n,p)-(sc/2)\n    E = sige*randn(n,1)\n    xstar = X * Wx\n    ystar = zscore([6.3*xstar[:,1].*exp(-0.1*xstar[:,1].^2) randn(n,1)],1)\n    Y =  ystar / Wy\n    return zscore(X,1), Y, xstar, ystar\nend\n\ncreateDF = function(df::Int, Y::Matrix{Float64})\n    Xs = bf(gKCCAm.R[:,1], df)\n    CCAm = cca([-9. -9.], Xs, Y)\n    return DataFrame(x=gkCCAm.R[:,1], y= CCAm.T[:,1], y2 = CCAm.R[:,1]-mean(CCAm.R[:,1]), df= i df /i =$df )\nend    \n\nsrand(1234)\nX, Y, xstar, ystar = simfn(200, 2,30.0, 0.1)\n\nkpars = GaussianKP(X)\ngKCCAm = gKCCA([0.2, -5, 1], X, Y, kpars )\n\nplotfn = function(v) \n    mlfs = 10pt\n    D1= vcat([createDF(df, Y) for df in v]...)\n\nplot(D1, xgroup=:df,\n    Geom.subplot_grid(Coord.cartesian(ymin=-3, ymax=3),\n        layer(x=:x, y=:y2, Geom.line,  Theme(default_color=colorant red )),\n        layer(x=:x, y=:y, Geom.point)\n    ),\n    Guide.ylabel( b YA /b sub 1 /sub ),\n    Theme(plot_padding=0mm, major_label_font_size=mlfs)\n )\nend\n\npb = plotfn(4:6)\nGadfly.add_plot_element!(pb, Guide.xlabel( b XW /b sub 1 /sub  (gKCCA)  ))\n\nM = Array(Compose.Context, (2,1))\nM[1] = compose(context(0,0, 1.0, 0.45), render(plotfn(1:3)))\nM[2] = compose(context(0,0, 1.0, 0.55), render(pb))\n\nvstack(M...)", 
            "title": "Example 2"
        }, 
        {
            "location": "/man/tpSST/", 
            "text": "Tropical Pacific SSTs\n\n\nusing DSP\nusing StatsBase: zscore, autocor\nusing DataFrames\nusing Compose, Gadfly\nusing SpacetimeFields, CoupledFields\n\nexpand_grid(xv, yv) = vcat([ [x y] for x in xv, y in yv]...) \ntheme_red = Theme(default_color=colorant\nred\n)\n\n# NetCDF file:\n# https://www.esrl.noaa.gov/psd/data/gridded/data.noaa.ersst.v4.html \nf2 = \nsst.mnmean.v4.nc\n\n\n# NetCDF.ncinfo(f2)\n\next1 = extent(126, 294 ,-19, 19)\nr1 = nc2field(f2, \nsst\n, ext1)\n\ncoord_map = Coord.cartesian(xmin=ext1.xmin-1, xmax=ext1.xmax+1, ymin=ext1.ymin-1, ymax=ext1.ymax+1)\nxtix = Guide.xticks(ticks=collect(120:20:280)+10)\nytix = Guide.yticks(ticks=collect(-20:10:ext1.ymax+1))\n\nt1 = ((1854+1/24):1/12:2017)[1:length(r1.time)]\nti = ((1945-1854)*12+1):((2010-1854)*12)\nt2 = collect(t1[ti])\n\nM1 = convert(Matrix, r1)\n\nfilt1 = digitalfilter(Bandpass(1/36, 1/23, fs=1), Butterworth(3))\nfilt2 = digitalfilter(Bandpass(1/72, 1/48, fs=1), Butterworth(3))\n\nhpfield = filtfilt(filt1, M1)\nlpfield = filtfilt(filt2, M1)\n\nlat = convert(Vector{Float64},llgrid(r1)[1][:,2] )\n\n# Can change the [0.85, 0.85] below \nlag = 0\nZ0 = InputSpace(lpfield[ti+lag,:],hpfield[ti,:]) # zscores\nZ = InputSpace(lpfield[ti+lag,:], hpfield[ti,:], [0.85, 0.85], lat[r1.good])\n\nkpars = GaussianKP(Z.X)\n\nsrand(1234)\ngrid1 = expand_grid(linspace(0.15, 2.0, 10), linspace(-7, -2, 6))\ngrid1 = [grid1 fill(2.0, size(grid1,1)) ]\n@time par = CVfn(grid1, Z.X, Z.Y, gKCCA, GaussianKP, dcv=1)\ngKCCAm = gKCCA(par, Z.X, Z.Y, kpars)\n\n############### Graphics Functions ################\n\nfunction expvar{Q\n:Matrix{Float64}}(j::Union{Int,Range{Int}}, model::ModelObj, X::Q, Y::Q)\n    R = model.R[:,j][:,:]\n    T = model.T[:,j][:,:]\n    P_R = R * (R'R \\ R')\n    P_T = T * (T'T \\ T')\n    return    [ trace(X'*P_R*X)/trace(X'X)  trace(Y'*P_T*Y)/trace(Y'Y) ]\nend\n\nfunction fncor(j::Int, model::ModelObj)\n    D = DataFrame(R = model.R[:,j], T = model.T[:,j], g=\n \n)\n    D[:Component] = \nb\nj=$j\n/b\n\n    return D\nend    \n\nfunction fnmap(j::Int, model::ModelObj, Z::InputSpace, r1::stfield)\n    b = [ cor(model.R[:,j], Z.X); cor(model.T[:,j], Z.Y) ]\n    r2 = copy(r1, layers=1:2);\n    r2.data[repmat(r2.good,2)] = b'\n    label = [\nXW\n, \nYA\n]\n    D = convert(DataFrame, r2, 1:2, label)\n    D[:Component] = \nComponent $j\n\n    return D\nend    \n\n###################################################\n\n# Explained Variance\nfunction fn1{Q\n:Matrix{Float64}}(j::Int, X::Q, Y::Q)\n    z = vec( expvar(j, gKCCAm, X, Y) )\n    rt = [\nR\u00b2\nsub\nX\n/sub\n=\n, \nR\u00b2\nsub\nY\n/sub\n=\n]\n    zt = [x[1]*\n$(x[2])%\n for x in zip(rt, round(Int64,z*100))]\n    return DataFrame(g=[\nXW\n,\nYA\n], Component=\nComponent $j\n, lon=255, lat=20, label = zt  )\nend\n\nD4mapt = vcat([fn1(j, lpfield[ti+lag,:], hpfield[ti,:]) for j in 1:2]...)\n\n# Correlation pattern\nD4cor = vcat([fncor(j, gKCCAm) for j in 1:2]...)\nD4map = vcat([fnmap(j, gKCCAm, Z0, r1) for j in 1:2]...)\n\n# Figure 4\n\n# _j = \nsub\nj\n/sub\n\n_j = \n\u2c7c\n\nlabela = [\nb\nXW\n/b\n*_j, \nb\nYA\n/b\n*_j]\nlabelb = [string(\ni\nr\n/i\n(\n,labela[1],\n, \nb\nX\n/b\n)\n), string(\ni\nr\n/i\n(\n,labela[2],\n, \nb\nY\n/b\n)\n)]\nlabelc = [\nLongitude (\u00b0E)\n, \nLatitude (\u00b0N)\n]\n\npa = plot(D4cor, x=:R, y=:T, xgroup=:g, ygroup=:Component,\nGeom.subplot_grid(\n    layer(Geom.point),\n    layer(Geom.smooth(smoothing=0.75), theme_red, order=2),\n    Guide.xlabel(labela[1])\n),\n    Guide.xlabel(\n),Guide.ylabel(labela[2]),\n    Guide.title(\n \n),\n    Theme(plot_padding=0mm, default_point_size=0.6mm, background_color=colorant\nwhite\n)\n)\n\n\npb = plot(D4map, xgroup=:g, ygroup=:Component,\n    Geom.subplot_grid(coord_map, xtix, ytix,\n        layer( x=:lon, y=:lat, color= :z, Geom.rectbin, Theme(bar_spacing=-0.5mm)),\n        layer(D4mapt, x=:lon, y=:lat, xgroup=:g, ygroup=:Component, \n            label=:label, Geom.label(position=:centered), order=2),\n        Guide.xlabel(labelc[1]), Guide.ylabel(\n\\n\n)\n    ),\n    Guide.xlabel(\n), Guide.ylabel(labelc[2]),\n    Guide.colorkey(\ni\nr\n/i\n),\n    Guide.title(string(\n \n^5,labelb[1],\n \n^35,labelb[2])),\n    Theme(plot_padding=0mm, key_position=:right, background_color=colorant\nwhite\n)\n)\n\n\nM = Array(Compose.Context, (1,2))\nM[1] = compose(context(0,0,1/4,1), render(pa))\nM[2] = compose(context(0,0,3/4,1), render(pb));\n\np1 = hstack(M...)\ndraw(PNG(\ngKMAP.png\n,8inch,3.3inch), p1)", 
            "title": "Tropical Pacific SSTs"
        }, 
        {
            "location": "/man/tpSST/#tropical-pacific-ssts", 
            "text": "using DSP\nusing StatsBase: zscore, autocor\nusing DataFrames\nusing Compose, Gadfly\nusing SpacetimeFields, CoupledFields\n\nexpand_grid(xv, yv) = vcat([ [x y] for x in xv, y in yv]...) \ntheme_red = Theme(default_color=colorant red )\n\n# NetCDF file:\n# https://www.esrl.noaa.gov/psd/data/gridded/data.noaa.ersst.v4.html \nf2 =  sst.mnmean.v4.nc \n\n# NetCDF.ncinfo(f2)\n\next1 = extent(126, 294 ,-19, 19)\nr1 = nc2field(f2,  sst , ext1)\n\ncoord_map = Coord.cartesian(xmin=ext1.xmin-1, xmax=ext1.xmax+1, ymin=ext1.ymin-1, ymax=ext1.ymax+1)\nxtix = Guide.xticks(ticks=collect(120:20:280)+10)\nytix = Guide.yticks(ticks=collect(-20:10:ext1.ymax+1))\n\nt1 = ((1854+1/24):1/12:2017)[1:length(r1.time)]\nti = ((1945-1854)*12+1):((2010-1854)*12)\nt2 = collect(t1[ti])\n\nM1 = convert(Matrix, r1)\n\nfilt1 = digitalfilter(Bandpass(1/36, 1/23, fs=1), Butterworth(3))\nfilt2 = digitalfilter(Bandpass(1/72, 1/48, fs=1), Butterworth(3))\n\nhpfield = filtfilt(filt1, M1)\nlpfield = filtfilt(filt2, M1)\n\nlat = convert(Vector{Float64},llgrid(r1)[1][:,2] )\n\n# Can change the [0.85, 0.85] below \nlag = 0\nZ0 = InputSpace(lpfield[ti+lag,:],hpfield[ti,:]) # zscores\nZ = InputSpace(lpfield[ti+lag,:], hpfield[ti,:], [0.85, 0.85], lat[r1.good])\n\nkpars = GaussianKP(Z.X)\n\nsrand(1234)\ngrid1 = expand_grid(linspace(0.15, 2.0, 10), linspace(-7, -2, 6))\ngrid1 = [grid1 fill(2.0, size(grid1,1)) ]\n@time par = CVfn(grid1, Z.X, Z.Y, gKCCA, GaussianKP, dcv=1)\ngKCCAm = gKCCA(par, Z.X, Z.Y, kpars)\n\n############### Graphics Functions ################\n\nfunction expvar{Q :Matrix{Float64}}(j::Union{Int,Range{Int}}, model::ModelObj, X::Q, Y::Q)\n    R = model.R[:,j][:,:]\n    T = model.T[:,j][:,:]\n    P_R = R * (R'R \\ R')\n    P_T = T * (T'T \\ T')\n    return    [ trace(X'*P_R*X)/trace(X'X)  trace(Y'*P_T*Y)/trace(Y'Y) ]\nend\n\nfunction fncor(j::Int, model::ModelObj)\n    D = DataFrame(R = model.R[:,j], T = model.T[:,j], g=   )\n    D[:Component] =  b j=$j /b \n    return D\nend    \n\nfunction fnmap(j::Int, model::ModelObj, Z::InputSpace, r1::stfield)\n    b = [ cor(model.R[:,j], Z.X); cor(model.T[:,j], Z.Y) ]\n    r2 = copy(r1, layers=1:2);\n    r2.data[repmat(r2.good,2)] = b'\n    label = [ XW ,  YA ]\n    D = convert(DataFrame, r2, 1:2, label)\n    D[:Component] =  Component $j \n    return D\nend    \n\n###################################################\n\n# Explained Variance\nfunction fn1{Q :Matrix{Float64}}(j::Int, X::Q, Y::Q)\n    z = vec( expvar(j, gKCCAm, X, Y) )\n    rt = [ R\u00b2 sub X /sub = ,  R\u00b2 sub Y /sub = ]\n    zt = [x[1]* $(x[2])%  for x in zip(rt, round(Int64,z*100))]\n    return DataFrame(g=[ XW , YA ], Component= Component $j , lon=255, lat=20, label = zt  )\nend\n\nD4mapt = vcat([fn1(j, lpfield[ti+lag,:], hpfield[ti,:]) for j in 1:2]...)\n\n# Correlation pattern\nD4cor = vcat([fncor(j, gKCCAm) for j in 1:2]...)\nD4map = vcat([fnmap(j, gKCCAm, Z0, r1) for j in 1:2]...)\n\n# Figure 4\n\n# _j =  sub j /sub \n_j =  \u2c7c \nlabela = [ b XW /b *_j,  b YA /b *_j]\nlabelb = [string( i r /i ( ,labela[1], ,  b X /b ) ), string( i r /i ( ,labela[2], ,  b Y /b ) )]\nlabelc = [ Longitude (\u00b0E) ,  Latitude (\u00b0N) ]\n\npa = plot(D4cor, x=:R, y=:T, xgroup=:g, ygroup=:Component,\nGeom.subplot_grid(\n    layer(Geom.point),\n    layer(Geom.smooth(smoothing=0.75), theme_red, order=2),\n    Guide.xlabel(labela[1])\n),\n    Guide.xlabel( ),Guide.ylabel(labela[2]),\n    Guide.title(   ),\n    Theme(plot_padding=0mm, default_point_size=0.6mm, background_color=colorant white )\n)\n\n\npb = plot(D4map, xgroup=:g, ygroup=:Component,\n    Geom.subplot_grid(coord_map, xtix, ytix,\n        layer( x=:lon, y=:lat, color= :z, Geom.rectbin, Theme(bar_spacing=-0.5mm)),\n        layer(D4mapt, x=:lon, y=:lat, xgroup=:g, ygroup=:Component, \n            label=:label, Geom.label(position=:centered), order=2),\n        Guide.xlabel(labelc[1]), Guide.ylabel( \\n )\n    ),\n    Guide.xlabel( ), Guide.ylabel(labelc[2]),\n    Guide.colorkey( i r /i ),\n    Guide.title(string(   ^5,labelb[1],   ^35,labelb[2])),\n    Theme(plot_padding=0mm, key_position=:right, background_color=colorant white )\n)\n\n\nM = Array(Compose.Context, (1,2))\nM[1] = compose(context(0,0,1/4,1), render(pa))\nM[2] = compose(context(0,0,3/4,1), render(pb));\n\np1 = hstack(M...)\ndraw(PNG( gKMAP.png ,8inch,3.3inch), p1)", 
            "title": "Tropical Pacific SSTs"
        }, 
        {
            "location": "/lib/library/", 
            "text": "Library\n\n\n\n\nContents\n\n\n\n\nLibrary\n\n\nContents\n\n\nTypes\n\n\nFunctions\n\n\n\n\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nCoupledFields.InputSpace\n \n \nType\n.\n\n\nInputSpace: A type to hold the `X` and `Y` fields of the Input space\n\n\n\n\nInputSpace(X, Y, d, lat): The fields are whitened if \nd=[d1, d2]\n is supplied. Area weighting is applied if \nlat\n is supplied.      \n\n\nsource\n\n\n#\n\n\nCoupledFields.ModelObj\n \n \nType\n.\n\n\nModelObj: A type to hold statistical model results\n\n\n\n\nSuch as the matrices \nW, R, A, T\n, where \nR=XW\n and \nT=YA\n.  \n\n\nsource\n\n\n#\n\n\nCoupledFields.KernelParameters\n \n \nType\n.\n\n\nKernelParameters: An abstract type.\n\n\n\n\nAll KernelParameters types contain certain parameters which are later passed to internal functions \nKf\n and \n\u2207Kf\n. \n\n\nA KernelParameters type is set using e.g. \nPolynomialKP(X::Matrix{Float64})\n or \nGaussianKP(X::Matrix{Float64})\n. \n\n\nsource\n\n\n#\n\n\nCoupledFields.GaussianKP\n \n \nType\n.\n\n\nGaussianKP: For the gaussian kernel\n\n\n\n\nsource\n\n\n#\n\n\nCoupledFields.PolynomialKP\n \n \nType\n.\n\n\nPolynomialKP: For the polynomial kernel\n\n\n\n\nsource\n\n\n\n\nFunctions\n\n\n#\n\n\nCoupledFields.CVfn\n \n \nMethod\n.\n\n\nCVfn{T\n:Matrix{Float64}}(parm::T, X::T, Y::T, modelfn::Function, kerneltype::DataType; verbose::Bool=true, dcv::Int64=2)\n\n\n\n\nCross-validation function\n\n\nsource\n\n\n#\n\n\nCoupledFields.Rsq_adj\n \n \nMethod\n.\n\n\nRsq_adj{T\n:Array{Float64}}(Tx::T, Ty::T, df::Int):\n\n\n\n\nCross-validation metric\n\n\nsource\n\n\n#\n\n\nCoupledFields.bf\n \n \nMethod\n.\n\n\nbf(x::Vector{Float64}, df::Int):\n\n\n\n\nCompute a piecewise linear basis matrix for the vector x.\n\n\nsource\n\n\n#\n\n\nCoupledFields.cca\n \n \nMethod\n.\n\n\ncca{T\n:Matrix{Float64}}(v::Array{Float64}, X::T,Y::T):\n\n\n\n\nRegularized Canonical Correlation Analysis using SVD. \n\n\nsource\n\n\n#\n\n\nCoupledFields.gKCCA\n \n \nMethod\n.\n\n\ngKCCA(par::Array{Float64}, X::Matrix{Float64}, Y::Matrix{Float64}, kpars::KernelParameters):\n\n\n\n\nCompute the projection matrices and components for gKCCA.\n\n\nsource\n\n\n#\n\n\nCoupledFields.gradvecfield\n \n \nMethod\n.\n\n\ngradvecfield{N\n:Float64, T\n:Matrix{Float64}}(par::Array{N}, X::T, Y::T, kpars::KernelParameters ):\n\n\n\n\nCompute the gradient vector or gradient matrix at each instance of the \nX\n and \nY\n fields, by making use of a kernel feature space.\n\n\nsource\n\n\n#\n\n\nCoupledFields.whiten\n \n \nMethod\n.\n\n\nwhiten(x::Matrix{Float64}, d::Float64; lat=nothing): Whiten matrix\n\n\n\n\nd\n (0-1) Percentage variance of components to retain. \n\n\nlat\n Latitudinal area-weighting.\n\n\nsource", 
            "title": "Library"
        }, 
        {
            "location": "/lib/library/#library", 
            "text": "", 
            "title": "Library"
        }, 
        {
            "location": "/lib/library/#contents", 
            "text": "Library  Contents  Types  Functions", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/library/#types", 
            "text": "#  CoupledFields.InputSpace     Type .  InputSpace: A type to hold the `X` and `Y` fields of the Input space  InputSpace(X, Y, d, lat): The fields are whitened if  d=[d1, d2]  is supplied. Area weighting is applied if  lat  is supplied.        source  #  CoupledFields.ModelObj     Type .  ModelObj: A type to hold statistical model results  Such as the matrices  W, R, A, T , where  R=XW  and  T=YA .    source  #  CoupledFields.KernelParameters     Type .  KernelParameters: An abstract type.  All KernelParameters types contain certain parameters which are later passed to internal functions  Kf  and  \u2207Kf .   A KernelParameters type is set using e.g.  PolynomialKP(X::Matrix{Float64})  or  GaussianKP(X::Matrix{Float64}) .   source  #  CoupledFields.GaussianKP     Type .  GaussianKP: For the gaussian kernel  source  #  CoupledFields.PolynomialKP     Type .  PolynomialKP: For the polynomial kernel  source", 
            "title": "Types"
        }, 
        {
            "location": "/lib/library/#functions", 
            "text": "#  CoupledFields.CVfn     Method .  CVfn{T :Matrix{Float64}}(parm::T, X::T, Y::T, modelfn::Function, kerneltype::DataType; verbose::Bool=true, dcv::Int64=2)  Cross-validation function  source  #  CoupledFields.Rsq_adj     Method .  Rsq_adj{T :Array{Float64}}(Tx::T, Ty::T, df::Int):  Cross-validation metric  source  #  CoupledFields.bf     Method .  bf(x::Vector{Float64}, df::Int):  Compute a piecewise linear basis matrix for the vector x.  source  #  CoupledFields.cca     Method .  cca{T :Matrix{Float64}}(v::Array{Float64}, X::T,Y::T):  Regularized Canonical Correlation Analysis using SVD.   source  #  CoupledFields.gKCCA     Method .  gKCCA(par::Array{Float64}, X::Matrix{Float64}, Y::Matrix{Float64}, kpars::KernelParameters):  Compute the projection matrices and components for gKCCA.  source  #  CoupledFields.gradvecfield     Method .  gradvecfield{N :Float64, T :Matrix{Float64}}(par::Array{N}, X::T, Y::T, kpars::KernelParameters ):  Compute the gradient vector or gradient matrix at each instance of the  X  and  Y  fields, by making use of a kernel feature space.  source  #  CoupledFields.whiten     Method .  whiten(x::Matrix{Float64}, d::Float64; lat=nothing): Whiten matrix  d  (0-1) Percentage variance of components to retain.   lat  Latitudinal area-weighting.  source", 
            "title": "Functions"
        }
    ]
}